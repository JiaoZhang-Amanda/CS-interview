## DP Coding

### JAVA releted


### Leetcode

\#| Title|Difficulty
--|--|--
139   |    Word Break   |    Medium
140  |  Word Break II   |    Hard
377  |     Combination Sum IV   |    Medium
474    |   Ones and Zeroes    |   Medium
465   |    Optimal Account Balancing    |   Hard
276   |    Paint Fence  |     Easy
656   |    Coin Path   |    Hard
727    |   Minimum Window Subsequence   |    Hard
351   |    Android Unlock Patterns    |   Medium
361   |    Bomb Enemy  |     Medium

<details>
<summary>139. Word Break</summary>
Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words.

Input: s = "leetcode", wordDict = ["leet", "code"]
Output: true
Explanation: Return true because "leetcode" can be segmented as "leet code".
</details>

<details>
<summary>140. Word Break II</summary>
Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences.

Input:
s = "catsanddog"
wordDict = ["cat", "cats", "and", "sand", "dog"]
Output:
[
  "cats and dog",
  "cat sand dog"
]
</details>

<details>
<summary>337. Combination Sum IV </summary>
Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target.

Example:

nums = [1, 2, 3]
target = 4

The possible combination ways are:
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)

Note that different sequences are counted as different combinations.

Therefore the output is 7.
</details>

<details>
<summary>474. Ones and Zeroes</summary>
In the computer world, use restricted resource you have to generate maximum benefit is what we always want to pursue.

For now, suppose you are a dominator of m 0s and n 1s respectively. On the other hand, there is an array with strings consisting of only 0s and 1s.

Now your task is to find the maximum number of strings that you can form with given m 0s and n 1s. Each 0 and 1 can be used at most once.

Input: Array = {"10", "0001", "111001", "1", "0"}, m = 5, n = 3
Output: 4

Explanation: This are totally 4 strings can be formed by the using of 5 0s and 3 1s, which are “10,”0001”,”1”,”0”
</details>

<details>
<summary>465. Optimal Account Balancing </summary>
A group of friends went on holiday and sometimes lent each other money. For example, Alice paid for Bill's lunch for $10. Then later Chris gave Alice $5 for a taxi ride. We can model each transaction as a tuple (x, y, z) which means person x gave person y $z. Assuming Alice, Bill, and Chris are person 0, 1, and 2 respectively (0, 1, 2 are the person's ID), the transactions can be represented as [[0, 1, 10], [2, 0, 5]].

Given a list of transactions between a group of people, return the minimum number of transactions required to settle the debt.
Input:
[[0,1,10], [2,0,5]]

Output:
2
</details>

<details>
<summary>276.  Paint Fence</summary>
There is a fence with n posts, each post can be painted with one of the k colors.

You have to paint all the posts such that no more than two adjacent fence posts have the same color.

Return the total number of ways you can paint the fence.

Note:
n and k are non-negative integers.
</details>

<details>
<summary>656. Coin Path</summary>

</details>

<details>
<summary>727. Minimum Window Subsequence </summary>

</details>

<details>
<summary>351. Android Unlock Patterns</summary>

</details>

<details>
<summary>361. Bomb Enemy </summary>

</details>
